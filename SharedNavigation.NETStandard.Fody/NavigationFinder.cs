using Mono.Cecil;
using System.Collections.Generic;
using System.Linq;

namespace SharedNavigation.NETStandard.Fody
{
    public class NavigationFinder
    {
        private readonly ModuleWeaver moduleWeaver;
        private readonly TypeReference navigationActionInterface;

        public NavigationFinder(ModuleWeaver moduleWeaver)
        {
            this.moduleWeaver = moduleWeaver;
            navigationActionInterface = moduleWeaver.ModuleDefinition.ImportReference(
                moduleWeaver.FindType(Constant.NavigationActionInterfaceFullName)
            );
        }

        private void logInfo(TypeDefinition typeDefinition, string message)
        {
            moduleWeaver.LogInfo($"{Constant.Tag}: {typeDefinition.FullName}: {message}");
        }

        private void logWarning(TypeDefinition typeDefinition, string message)
        {
            moduleWeaver.LogWarning($"{Constant.Tag}: {typeDefinition.FullName}: {message}");
        }

        private void logError(TypeDefinition typeDefinition, string message)
        {
            moduleWeaver.LogError($"{Constant.Tag}: {typeDefinition.FullName}: {message}");
        }

        public IEnumerable<NavigationViewDefinition> FindNavigationViewDefinitions()
        {
            foreach (TypeDefinition type in moduleWeaver.ModuleDefinition.Types)
            {
                if (isNavigationView(type, out TypeReference navigationViewModel) == false)
                {
                    continue;
                }

                var navigateMethods = findNavigateMethods(type).ToList();
                var canNavigateMethods = findCanNavigateMethods(type).ToList();

                if (navigateMethods.Select(x => x.injectPropertyName).Distinct().Count() != navigateMethods.Count)
                {
                    logWarning(type, $"{Constant.NavigateAttribute.Name} value is conflicted");
                }
                if (canNavigateMethods.Select(x => x.injectPropertyName).Distinct().Count() != canNavigateMethods.Count)
                {
                    logWarning(type, $"{Constant.CanNavigateAttribute.Name} value is conflicted");
                }

                var injectPropertyNames = new HashSet<string>();
                injectPropertyNames.AddRange(navigateMethods.Select(x => x.injectPropertyName));
                injectPropertyNames.AddRange(canNavigateMethods.Select(x => x.injectPropertyName));

                IList<NavigationActionDefinition> navigationActionDefinitions = injectPropertyNames
                    .Select(x => (name: x, property: findInjectProperty(type, navigationViewModel.Resolve(), x)))
                    .Where(x => x.property is NavigationPropertyDefinition)
                    .Select(x =>
                    {
                        MethodDefinition navigateMethod = navigateMethods
                            .Where(y => y.injectPropertyName == x.name)
                            .Select(y => y.method)
                            .FirstOrDefault();
                        MethodDefinition canNavigateMethod = canNavigateMethods
                            .Where(y => y.injectPropertyName == x.name)
                            .Select(y => y.method)
                            .FirstOrDefault();
                        return new NavigationActionDefinition(x.name, x.property, navigateMethod, canNavigateMethod);
                    })
                    .ToList();

                var registerNavigationMethod = findRegisterNavigation(type, navigationViewModel);
                if (registerNavigationMethod == null)
                {
                    logWarning(type, $"not found {Constant.RegisterNavigationByAutoGenerated.Name}");
                    continue;
                }

                yield return new NavigationViewDefinition(type, navigationActionDefinitions, registerNavigationMethod);
            }
        }

        private bool isNavigationView(TypeDefinition type, out TypeReference navigationViewModel)
        {
            if (type.IsInterface)
            {
                logInfo(type, "is interface");
                navigationViewModel = default;
                return false;
            }
            if (type.HasInterfaces == false)
            {
                logInfo(type, "has not interface");
                navigationViewModel = default;
                return false;
            }
            if (type.HasMethods == false)
            {
                logInfo(type, "has not method");
                navigationViewModel = default;
                return false;
            }

            if (isImplementedNavigationViewInterface(type, out navigationViewModel) == false)
            {
                logInfo(type, $"not implement {Constant.NavigationView.Name}");
                return false;
            }

            return true;
        }

        private bool isImplementedNavigationViewInterface(TypeDefinition type, out TypeReference navigationViewModel)
        {
            foreach (InterfaceImplementation interfaceImplementation in type.Interfaces)
            {
                TypeReference interfaceType = interfaceImplementation.InterfaceType;
                if (interfaceType.MatchGenericType(Constant.NavigationView) &&
                    interfaceType is GenericInstanceType genericInterfaceType &&
                    genericInterfaceType.HasGenericArguments)
                {
                    navigationViewModel = moduleWeaver.ModuleDefinition.ImportReference(
                        genericInterfaceType.GenericArguments.First()
                    );
                    return true;
                }
            }

            navigationViewModel = default;
            return false;
        }

        private IEnumerable<(MethodDefinition method, string injectPropertyName)> findNavigateMethods(
            TypeDefinition navigationView)
        {
            foreach (MethodDefinition method in navigationView.Methods)
            {
                if (tryGetInjectPropertyNameInNavigateAttribute(navigationView, method, out string injectPropertyName) == false)
                {
                    logInfo(navigationView, $"{method.Name}: has not {Constant.NavigateAttribute.Name}");
                    continue;
                }

                if (validNavigateMethod(navigationView, method) == false)
                {
                    continue;
                }

                yield return (method, injectPropertyName);
            }
        }

        private bool tryGetInjectPropertyNameInNavigateAttribute(
            TypeDefinition navigationView,
            MethodDefinition method,
            out string injectPropertyName)
        {
            foreach (CustomAttribute customAttribute in method.CustomAttributes)
            {
                if (customAttribute.AttributeType.MatchAttribute(Constant.NavigateAttribute))
                {
                    if (customAttribute.ConstructorArguments.Count != 1 ||
                        customAttribute.ConstructorArguments[0].Value == null)
                    {
                        logError(
                            navigationView,
                            $"{method.Name}: {Constant.NavigateAttribute.Name} has not constructor argument"
                        );
                        continue;
                    }

                    injectPropertyName = customAttribute.ConstructorArguments[0].Value.ToString();
                    return true;
                }
            }

            injectPropertyName = default;
            return false;
        }

        private bool validNavigateMethod(TypeDefinition navigationView, MethodDefinition method)
        {
            if (method.HasParameters == false || method.Parameters.Count != 1)
            {
                logWarning(
                    navigationView,
                    $"{method.Name}: {Constant.NavigateAttribute.Name} method must have 1 parameter"
                );
                return false;
            }

            if (method.ReturnType.MatchType(Constant.Task) == false ||
                method.ReturnType.HasGenericParameters)
            {
                logWarning(
                    navigationView,
                    $"{method.Name}: {Constant.NavigateAttribute.Name} method must return Task"
                );
                return false;
            }

            // not look parameter type, because it checked when runtime.

            return true;
        }

        private IEnumerable<(MethodDefinition method, string injectPropertyName)> findCanNavigateMethods(
            TypeDefinition navigationView)
        {
            foreach (MethodDefinition method in navigationView.Methods)
            {
                if (tryGetInjectPropertyNameInCanNavigateAttribute(navigationView, method, out string injectPropertyName) == false)
                {
                    logInfo(navigationView, $"{method.Name}: has not {Constant.CanNavigateAttribute.Name}");
                    continue;
                }

                if (validCanNavigateMethod(navigationView, method) == false)
                {
                    continue;
                }

                yield return (method, injectPropertyName);
            }
        }

        private bool tryGetInjectPropertyNameInCanNavigateAttribute(
            TypeDefinition navigationView,
            MethodDefinition method,
            out string injectPropertyName)
        {
            foreach (CustomAttribute customAttribute in method.CustomAttributes)
            {
                if (customAttribute.AttributeType.MatchAttribute(Constant.CanNavigateAttribute))
                {
                    if (customAttribute.ConstructorArguments.Count != 1 ||
                        customAttribute.ConstructorArguments[0].Value == null)
                    {
                        logError(
                            navigationView,
                            $"{method.Name}: {Constant.NavigateAttribute.Name} has not constructor argument"
                        );
                        continue;
                    }

                    injectPropertyName = customAttribute.ConstructorArguments[0].Value.ToString();
                    return true;
                }
            }

            injectPropertyName = default;
            return false;
        }

        private bool validCanNavigateMethod(TypeDefinition navigationView, MethodDefinition method)
        {
            if (method.HasParameters == false || method.Parameters.Count != 1)
            {
                logWarning(
                    navigationView,
                    $"{method.Name}: {Constant.CanNavigateAttribute.Name} method must have 1 parameter"
                );
                return false;
            }

            if (method.ReturnType.MetadataType != MetadataType.Boolean)
            {
                logWarning(
                    navigationView,
                    $"{method.Name}: {Constant.CanNavigateAttribute.Name} method must return bool"
                );
                return false;
            }

            // not look parameter type, because it checked when runtime.

            return true;
        }

        private NavigationPropertyDefinition findInjectProperty(
            TypeDefinition navigationView,
            TypeDefinition navigationViewModel,
            string propertyName)
        {
            PropertyDefinition property = navigationViewModel
                .Properties
                .FirstOrDefault(x => x.Name == propertyName);

            if (property is null)
            {
                logWarning(navigationViewModel, $"{propertyName} was not found");
                return null;
            }
            if (property.PropertyType.MatchGenericType(Constant.NavigationCommand) == false)
            {
                logWarning(navigationViewModel, $"{propertyName} type not equal {Constant.NavigationCommand.Name}");
                return null;
            }
            if (property.CustomAttributes.Any(x => x.AttributeType.MatchAttribute(Constant.InjectNavigationAttribute)) == false)
            {
                logWarning(navigationViewModel, $"{propertyName} not has {Constant.InjectNavigationAttribute.Name}");
                return null;
            }

            TypeReference navigationCommandType = moduleWeaver.ModuleDefinition.ImportReference(property.PropertyType);
            var baseNavigationActionPropertySetter = navigationCommandType.Resolve()
                .Properties
                .First(x => x.Name == Constant.NavigationCommandOfNavigationAction.Name)
                .SetMethod;

            var navigationActionPropertySetter = new MethodReference(
                baseNavigationActionPropertySetter.Name,
                moduleWeaver.TypeSystem.VoidReference,
                navigationCommandType
            );
            navigationActionPropertySetter.HasThis = true;
            navigationActionPropertySetter.Parameters.Add(new ParameterDefinition(navigationActionInterface));

            return new NavigationPropertyDefinition(property.GetMethod, navigationActionPropertySetter);
        }

        private MethodDefinition findRegisterNavigation(TypeDefinition navigationView, TypeReference navigationViewModel)
        {
            bool isValidParameter(MethodReference method)
            {
                if (method.Parameters.Count != 2)
                {
                    logInfo(navigationView, $"{Constant.RegisterNavigationByAutoGenerated.Name} not have 2 parameter");
                    return false;
                }
                if (method.Parameters[0].ParameterType.Equals(navigationViewModel) == false)
                {
                    logInfo(navigationView, $"{Constant.RegisterNavigationByAutoGenerated.Name} not have view model parameter");
                    return false;
                }
                if (method.Parameters[1].ParameterType.MatchType(Constant.NavigationAction) == false)
                {
                    logInfo(navigationView, $"{Constant.RegisterNavigationByAutoGenerated.Name} not have navigation action parameter");
                    return false;
                }

                return true;
            }

            return navigationView
                .Methods
                // インターフェースメソッドの明示的な実装がされている場合は.overrideディレクティブが宣言されている
                .Where(x => x.Overrides.Any())
                // どの型に対して明示的な実装をしているかの確認
                .Where(x => x.Overrides.First().DeclaringType.MatchGenericType(Constant.NavigationView))
                .Where(x => x.Overrides.First().MatchMethod(Constant.RegisterNavigationByAutoGenerated))
                .FirstOrDefault() ??
                navigationView
                .Methods
                .Where(x => x.MatchMethod(Constant.RegisterNavigationByAutoGenerated))
                .Where(isValidParameter)
                .FirstOrDefault();
        }
    }
}
